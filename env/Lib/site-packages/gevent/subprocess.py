import os
import sys
import signal
import traceback
import pickle
import fcntl
import gc
from typing import Optional, Tuple, List, Set
from os import DEVNULL

# Constants
MAXFD = os.sysconf("SC_OPEN_MAX") if hasattr(os, 'sysconf') else 256
PIPE = -1
STDOUT = -2

class SubprocessError(Exception):
    """Base exception for subprocess errors"""
    pass

class TimeoutExpired(SubprocessError):
    def __init__(self, cmd, timeout, output=None, stderr=None):
        self.cmd = cmd
        self.timeout = timeout
        self.output = output
        self.stderr = stderr

class CalledProcessError(SubprocessError):
    def __init__(self, returncode, cmd, output=None, stderr=None):
        self.returncode = returncode
        self.cmd = cmd
        self.output = output
        self.stderr = stderr

class CompletedProcess:
    def __init__(self, args, returncode, stdout=None, stderr=None):
        self.args = args
        self.returncode = returncode
        self.stdout = stdout
        self.stderr = stderr

    def check_returncode(self):
        if self.returncode:
            raise CalledProcessError(self.returncode, self.args, self.stdout, self.stderr)

class Popen:
    def __init__(self, args, 
                 stdin=None, stdout=None, stderr=None,
                 shell=False, cwd=None, env=None,
                 preexec_fn=None, close_fds=True,
                 pass_fds=(), restore_signals=True,
                 start_new_session=False):
        
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self._devnull = None

        # Initialize pipes
        p2cread, p2cwrite = (-1, -1) if stdin is None else os.pipe()
        c2pread, c2pwrite = (-1, -1) if stdout is None else os.pipe()
        errread, errwrite = (-1, -1) if stderr is None else os.pipe()

        self._fds = {
            'p2cread': p2cread,
            'p2cwrite': p2cwrite,
            'c2pread': c2pread,
            'c2pwrite': c2pwrite,
            'errread': errread,
            'errwrite': errwrite
        }

        # Handle /dev/null
        if stdin == DEVNULL:
            self._devnull = os.open(os.devnull, os.O_RDONLY)
            p2cread = self._devnull
        if stdout == DEVNULL:
            self._devnull = os.open(os.devnull, os.O_WRONLY)
            c2pwrite = self._devnull
        if stderr == DEVNULL:
            self._devnull = os.open(os.devnull, os.O_WRONLY)
            errwrite = self._devnull

        # Fork and execute
        self.pid = os.fork()
        if self.pid == 0:
            self._child_exec(args, cwd, env, preexec_fn, close_fds, pass_fds,
                            restore_signals, start_new_session)
        else:
            self._parent_setup()

    def _child_exec(self, args, cwd, env, preexec_fn, close_fds, pass_fds,
                   restore_signals, start_new_session):
        try:
            # Child process setup
            if cwd:
                os.chdir(cwd)
            if env:
                os.environ.update(env)
            
            # Close unnecessary fds
            keep_fds = set(pass_fds)
            keep_fds.update({self._fds['p2cread'], self._fds['c2pwrite'], self._fds['errwrite']})
            self._close_fds(keep_fds)
            
            # Redirect stdin/stdout/stderr
            if self._fds['p2cread'] != -1:
                os.dup2(self._fds['p2cread'], 0)
            if self._fds['c2pwrite'] != -1:
                os.dup2(self._fds['c2pwrite'], 1)
            if self._fds['errwrite'] != -1:
                os.dup2(self._fds['errwrite'], 2)
            
            # Execute command
            os.execvp(args[0], args)
        except Exception as e:
            exc_data = pickle.dumps(e)
            os.write(self._fds['errwrite'], exc_data)
            os._exit(1)

    def _parent_setup(self):
        # Close child-side fds in parent
        for fd in [self._fds['p2cread'], self._fds['c2pwrite'], self._fds['errwrite']]:
            if fd != -1:
                os.close(fd)

    def _close_fds(self, keep: Set[int]):
        for fd in range(3, MAXFD):
            if fd not in keep:
                try:
                    os.close(fd)
                except OSError:
                    pass

    def communicate(self, input=None, timeout=None):
        # Simplified communication implementation
        if self.stdin and input:
            self.stdin.write(input)
            self.stdin.close()
        
        stdout = self.stdout.read() if self.stdout else None
        stderr = self.stderr.read() if self.stderr else None
        
        self.wait()
        return stdout, stderr

    def wait(self, timeout=None):
        pid, returncode = os.waitpid(self.pid, 0)
        self.returncode = returncode
        return self.returncode

def run(args, *, stdin=None, input=None, stdout=None, stderr=None,
        shell=False, timeout=None, check=False, capture_output=False):
    if capture_output:
        stdout = PIPE
        stderr = PIPE
    if input is not None:
        stdin = PIPE

    with Popen(args, stdin=stdin, stdout=stdout, stderr=stderr, shell=shell) as proc:
        try:
            stdout, stderr = proc.communicate(input, timeout=timeout)
        except TimeoutExpired:
            proc.kill()
            stdout, stderr = proc.communicate()
            raise TimeoutExpired(proc.args, timeout, output=stdout, stderr=stderr)
        except:
            proc.kill()
            raise

        if check and proc.returncode != 0:
            raise CalledProcessError(proc.returncode, args, stdout, stderr)
        
        return CompletedProcess(args, proc.returncode, stdout, stderr)